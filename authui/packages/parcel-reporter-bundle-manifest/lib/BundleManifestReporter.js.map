{"mappings":";;;;;;;;;;;;;;;;;;;AAGA,KAAK,CAAC,mCAAa,IAAI,CAAS,GAAK,CAAC;IACpC,MAAM,CAAC,CAAC,CAAC,OAAO,YAAY,CAAG;AACjC,CAAC;IAED,wCAiEG,GAjEY,GAAG,CAAC,4BAAQ,CAAC,CAAC;IAC3B,EAAyC,AAAzC,uCAAyC;UACnC,MAAM,EAAC,CAAC,QAAC,KAAK,YAAE,OAAO,EAAM,CAAC,EAAE,CAAC;QACrC,EAAE,EAAE,KAAK,CAAC,IAAI,KAAK,CAAc,eAC/B,MAAM;QAGR,KAAK,CAAC,eAAe,GAAG,GAAG,CAAC,GAAG;QAE/B,GAAG,EAAE,KAAK,CAAC,MAAM,IAAI,KAAK,CAAC,WAAW,CAAC,UAAU,GAC/C,EAAE,GAAG,MAAM,CAAC,QAAQ,EAAE,CAAC;YACrB,GAAG,CAAC,OAAO,GAAG,eAAe,CAAC,GAAG,CAAC,MAAM,CAAC,MAAM,CAAC,OAAO;YAEvD,EAAE,GAAG,OAAO,EAAE,CAAC;gBACb,OAAO,GAAG,CAAC,CAAC;gBACZ,eAAe,CAAC,GAAG,CAAC,MAAM,CAAC,MAAM,CAAC,OAAO,EAAE,OAAO;YACpD,CAAC;YAED,OAAO,CAAC,IAAI,CAAC,MAAM;QACrB,CAAC;QAGH,KAAK,CAAC,UAAU,GAAa,CAAC,CAAC;QAE/B,GAAG,EAAE,KAAK,EAAE,SAAS,EAAE,OAAO,KAAK,eAAe,CAAE,CAAC;YACnD,KAAK,CAAC,QAAQ,GAAa,CAAC;YAAA,CAAC;YAE7B,GAAG,EAAE,KAAK,CAAC,MAAM,IAAI,OAAO,CAAE,CAAC;oBAWf,GAAqB;gBAVnC,EASG,AATH;;;;;;;;;SASG,AATH,EASG,CACH,KAAK,CAAC,KAAK,IAAG,GAAqB,GAArB,MAAM,CAAC,YAAY,gBAAnB,GAAqB,cAArB,GAAqB,GAAI,MAAM,CAAC,cAAc,GAAG,CAAC;gBAChE,EAAE,EAAE,KAAK,EAAE,CAAC;oBACV,KAAK,CAAC,SAAS,GAAG,KAAK,CAAC,QAAQ;oBAChC,KAAK,CAAC,SAAS,GAAG,KAAK,CAAC,WAAW,CAAC,YAAY,CAAC,MAAM,CAAC,MAAM;oBAC9D,GAAG,CAAC,SAAS,GAAG,mCAAa,CAAC,qCAAI,CAAC,QAAQ,CAAC,SAAS,EAAE,SAAS;oBAChE,EAAE,EAAE,UAAU,CAAC,QAAQ,CAAC,SAAS,GAAG,CAAC;wBACnC,KAAK,CAAC,CAAC,GAAG,SAAS,CAAC,WAAW,CAAC,CAAG;wBACnC,SAAS,GACP,SAAS,CAAC,SAAS,CAAC,CAAC,EAAE,CAAC,IAAI,CAAS,WAAG,SAAS,CAAC,SAAS,CAAC,CAAC;oBACjE,CAAC;oBACD,UAAU,CAAC,IAAI,CAAC,SAAS;oBACzB,KAAK,CAAC,SAAS,GAAG,mCAAa,IAC1B,MAAM,CAAC,MAAM,CAAC,SAAS,CAAC,CAAC,EAAE,qCAAI,CAAC,QAAQ,CACzC,MAAM,CAAC,MAAM,CAAC,OAAO,EACrB,MAAM,CAAC,QAAQ;oBAInB,QAAQ,CAAC,SAAS,IAAI,SAAS;gBACjC,CAAC;YACH,CAAC;YAED,KAAK,CAAC,UAAU,MAAM,SAAS,CAAC,CAAC,EAAE,yCAAiB;YACpD,KAAK,CAAC,OAAO,CAAC,QAAQ,CAAC,SAAS,CAAC,UAAU,EAAE,IAAI,CAAC,SAAS,CAAC,QAAQ;YACpE,OAAO,CAAC,GAAG,EAAE,+BAA4B,EAAE,UAAU;QACvD,CAAC;IACH,CAAC;AACH,CAAC;AAGM,KAAK,CAAC,yCAAiB,GAAG,CAAsB","sources":["src/BundleManifestReporter.ts"],"sourcesContent":["import { Reporter } from \"@parcel/plugin\";\nimport path from \"path\";\n\nconst normalisePath = (p: string) => {\n  return p.replace(/[\\\\/]+/g, \"/\");\n};\n\nexport default new Reporter({\n  // TODO: Add type definition for Reporter\n  async report({ event, options }: any) {\n    if (event.type !== \"buildSuccess\") {\n      return;\n    }\n\n    const bundlesByTarget = new Map();\n\n    for (const bundle of event.bundleGraph.getBundles()) {\n      if (!bundle.isInline) {\n        let bundles = bundlesByTarget.get(bundle.target.distDir);\n\n        if (!bundles) {\n          bundles = [];\n          bundlesByTarget.set(bundle.target.distDir, bundles);\n        }\n\n        bundles.push(bundle);\n      }\n    }\n\n    const assetNames: string[] = [];\n\n    for (const [targetDir, bundles] of bundlesByTarget) {\n      const manifest: Manifest = {};\n\n      for (const bundle of bundles) {\n        /**\n         * Use main entry first as the key of the manifest, and fallback to the first asset of the bundle if main entry doesn't exist.\n         *\n         * Some bundle doesn't have a main entry (`bundle.getMainEntry()`); e.g. CSS bundle that's the result of CSS files imported from JS.\n         *\n         * The bundle could have multiple assets; e.g. multiple CSS files combined into one bundle,\n         * so we only choose the first one to avoid multiple bundle in the manifest.\n         *\n         * We cannot use the bundled file name without hash as a key because there' might be only hash; e.g. styles.css -> asdfjkl.css.\n         */\n        const asset = bundle.getMainEntry() ?? bundle.getEntryAssets()[0];\n        if (asset) {\n          const assetPath = asset.filePath;\n          const entryRoot = event.bundleGraph.getEntryRoot(bundle.target);\n          var assetName = normalisePath(path.relative(entryRoot, assetPath));\n          if (assetNames.includes(assetName)) {\n            const i = assetName.lastIndexOf(\".\");\n            assetName =\n              assetName.substring(0, i) + \"-modern\" + assetName.substring(i);\n          }\n          assetNames.push(assetName);\n          const bundleUrl = normalisePath(\n            `${bundle.target.publicUrl}/${path.relative(\n              bundle.target.distDir,\n              bundle.filePath\n            )}`\n          );\n\n          manifest[assetName] = bundleUrl;\n        }\n      }\n\n      const targetPath = `${targetDir}/${MANIFEST_FILENAME}`;\n      await options.outputFS.writeFile(targetPath, JSON.stringify(manifest));\n      console.log(`ðŸ“„ Wrote bundle manifest to: ${targetPath}`);\n    }\n  },\n});\n\nexport type Manifest = { [assetName: string]: string };\nexport const MANIFEST_FILENAME = \"parcel-manifest.json\";\n"],"names":[],"version":3,"file":"BundleManifestReporter.js.map","sourceRoot":"../"}