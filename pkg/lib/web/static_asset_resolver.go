package web

import (
	"context"

	// nolint:gosec
	"crypto/md5"
	"fmt"
	"net/url"
	"path"
	"strings"

	"github.com/authgear/authgear-server/pkg/lib/config"
	"github.com/authgear/authgear-server/pkg/util/intl"
	"github.com/authgear/authgear-server/pkg/util/readcloserthunk"
	"github.com/authgear/authgear-server/pkg/util/resource"
)

var StaticAssetResources = map[string]resource.Descriptor{
	"app-logo":           AppLogo,
	"app-logo-dark":      AppLogoDark,
	"favicon":            Favicon,
	"avatar-placeholder": AvatarPlaceholder,

	"authgear.css":             AuthgearCSS,
	"authgear-light-theme.css": AuthgearLightThemeCSS,
	"authgear-dark-theme.css":  AuthgearDarkThemeCSS,
}

type ResourceManager interface {
	Read(desc resource.Descriptor, view resource.View) (interface{}, error)
}

type StaticAssetResolver struct {
	Context            context.Context
	Config             *config.HTTPConfig
	Localization       *config.LocalizationConfig
	StaticAssetsPrefix config.StaticAssetURLPrefix
	Resources          ResourceManager
}

func (r *StaticAssetResolver) StaticAssetURL(id string) (string, error) {
	desc, ok := StaticAssetResources[id]
	if !ok {
		return "", fmt.Errorf("unknown static asset: %s", id)
	}

	preferredLanguageTags := intl.GetPreferredLanguageTags(r.Context)
	result, err := r.Resources.Read(desc, resource.EffectiveResource{
		SupportedTags: r.Localization.SupportedLanguages,
		DefaultTag:    *r.Localization.FallbackLanguage,
		PreferredTags: preferredLanguageTags,
	})
	if err != nil {
		return "", err
	}

	asset := result.(*StaticAsset)

	assetPath := strings.TrimPrefix(asset.Path, StaticAssetResourcePrefix)

	b, err := readcloserthunk.Performance_Bytes(asset.ReadCloserThunk)
	if err != nil {
		return "", err
	}

	// md5 is used to compute the hash in the filename for caching purpose only
	// nolint:gosec
	hash := md5.Sum(b)

	hashPath := PathWithHash(assetPath, fmt.Sprintf("%x", hash))
	return staticAssetURL(r.Config.PublicOrigin, string(r.StaticAssetsPrefix), hashPath)
}

func (r *StaticAssetResolver) GeneratedStaticAssetURL(key string) (string, error) {
	desc := GeneratedAsset

	assetPath, err := desc.(*GeneratedAssetDescriptor).GetAssetPathForKey(key)
	if err != nil {
		return "", err
	}

	return staticAssetURL(r.Config.PublicOrigin, path.Join(string(r.StaticAssetsPrefix), "generated"), assetPath)
}

func staticAssetURL(origin string, prefix string, assetPath string) (string, error) {
	o, err := url.Parse(origin)
	if err != nil {
		return "", err
	}
	u, err := o.Parse(prefix)
	if err != nil {
		return "", err
	}
	u.Path = path.Join(u.Path, assetPath)
	return u.String(), nil
}

func PathWithHash(filePath string, hash string) string {
	extension := path.Ext(filePath)
	nameOnly := strings.TrimSuffix(filePath, extension)
	return fmt.Sprintf("%s.%s%s", nameOnly, hash, extension)
}

func ParsePathWithHash(hashedPath string) (filePath string, hash string) {
	extension := path.Ext(hashedPath)
	if extension == "" {
		return "", ""
	}

	if IsSourceMapPath(hashedPath) {
		extension = fmt.Sprintf("%s%s", path.Ext(strings.TrimSuffix(hashedPath, extension)), extension)
	}

	nameWithHash := strings.TrimSuffix(hashedPath, extension)
	dotIdx := strings.LastIndex(nameWithHash, ".")
	if dotIdx == -1 {
		// hashedPath doesn't have extension, e.g. filename.hash
		// so the extension is the hashed
		filePath = nameWithHash
		hash = strings.TrimPrefix(extension, ".")
		return
	}

	nameOnly := nameWithHash[:dotIdx]

	hash = nameWithHash[dotIdx+1:]
	filePath = fmt.Sprintf("%s%s", nameOnly, extension)

	return
}

func LookLikeAHash(s string) bool {
	// hash that generated by parcel should be in length of 8
	return len(s) == 8
}

func IsSourceMapPath(hashedPath string) bool {
	mapExtension := path.Ext(hashedPath)
	return mapExtension == ".map"
}
